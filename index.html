<!DOCTYPE html>
<html lang="en">
  <head>
    <title>
      Gamepad
    </title>
    <meta charset="utf-8"><!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->

    <script src='https://www.w3.org/Tools/respec/respec-w3c' class=
    'remove'></script>
    <script class='remove'>
      var respecConfig = {
          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:           "ED",
          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          // subtitle   :  "an excellent document",

          // if you wish the publication date to be other than today, set this
          //publishDate:  "2011-01-01",

          // if the specification's copyright date is a range of years, specify
          // the start date here:
          // copyrightStart: "2005"

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          testSuiteURI: "https://wpt.live/gamepad/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Steve Agoston", w3cid: "103815",
                company: "Sony", companyURL: "https://www.sony.com/"},
              { name: "James Hollyer", w3cid: "115233",
                company: "Google", companyURL: "https://www.google.com/"},
              { name: "Matt Reynolds", w3cid: "105511",
                company: "Google", companyURL: "https://www.google.com/"},
          ],

          formerEditors: [
              { name: "Brandon Jones", url: "http://tojicode.com/",
                company: "Google", companyURL: "http://www.google.com/",
                w3cid: 87824 },
              { name: "Scott Graham", url: "http://h4ck3r.net/",
                company: "Google", companyURL: "https://www.google.com/",
                w3cid: 49028 },
              { name: "Ted Mielczarek", url: "http://ted.mielczarek.org/",
                company: "Mozilla", companyURL: "http://www.mozilla.org/",
                w3cid: 49656 },
          ],

          github: "w3c/gamepad",

          group: "webapps",

          implementationReportURI: "https://wpt.fyi/results/gamepad",
          caniuse: "gamepad",
          xref: ["HTML", "DOM", "PERMISSIONS-POLICY", "HR-TIME", "Infra"],
      };
    </script>

  </head>
  <body data-cite="">
    <section id='abstract'>
      <p>
        The Gamepad specification defines a low-level interface that represents
        gamepad devices.
      </p>
    </section>
    <section id='sotd'>
      <p>
        This is a work in progress.
      </p>
    </section>
    <section id='introduction' class='informative'>
      <h2>
        Introduction
      </h2>
      <p>
        Some <a>user agent</a>s have connected gamepad devices. These devices
        are desirable and suited to input for gaming applications, and for "10
        foot" user interfaces (presentations, media viewers).
      </p>
      <p>
        Currently, the only way for a gamepad to be used as input would be to
        emulate mouse or keyboard events, however this would lose information
        and require additional software outside of the <a>user agent</a> to
        accomplish emulation.
      </p>
      <p>
        Meanwhile, native applications are capable of accessing these devices
        via system APIs.
      </p>
      <p>
        The Gamepad API provides a solution to this problem by specifying
        interfaces that allow web applications to directly act on gamepad data.
      </p>
    </section>
    <section>
      <h2>
        Scope
      </h2>
      <p>
        Interfacing with external devices designed to control games has the
        potential to become large and intractable if approached in full
        generality. In this specification we explicitly choose to narrow scope
        to provide a useful subset of functionality that can be widely
        implemented and broadly useful.
      </p>
      <p>
        Specifically, we choose to only support the functionality required to
        support gamepads. Support for gamepads requires two input types:
        buttons and axes. Both buttons and axes are reported as analog values,
        buttons ranging from [0..1], and axes ranging from [-1..1].
      </p>
      <p>
        While the primary goal is support for gamepad devices, supporting these
        two types of analog inputs allows support for other similar devices
        common to current gaming systems including joysticks, driving wheels,
        pedals, and accelerometers. As such, the name "gamepad" is exemplary
        rather than trying to be a generic name for the entire set of devices
        addressed by this specification.
      </p>
      <p>
        We specifically exclude support for more complex devices that may also
        be used in some gaming contexts, including those that that do motion
        sensing, depth sensing, video analysis, gesture recognition, and so on.
      </p>
    </section>
    <section data-dfn-for="Gamepad" data-link-for="Gamepad">
      <h2>
        <dfn>Gamepad</dfn> interface
      </h2>
      <p>
        This interface defines an individual gamepad device.
      </p>
      <pre class="idl" data-cite="HR-TIME">
        [Exposed=Window, SecureContext]
        interface Gamepad {
          readonly attribute DOMString id;
          readonly attribute long index;
          readonly attribute boolean connected;
          readonly attribute DOMHighResTimeStamp timestamp;
          readonly attribute GamepadMappingType mapping;
          readonly attribute FrozenArray&lt;double&gt; axes;
          readonly attribute FrozenArray&lt;GamepadButton&gt; buttons;
        };
      </pre>
      <p>
        Instances of {{Gamepad}} are created with the internal slots described in the following table:
      </p>
      <table class="simple" dfn-for="Gamepad">
        <tr>
          <th>Internal slot
          <th>Initial value
          <th>Description (non-normative)
        <tr>
          <td><dfn data-dfn-for="Gamepad">[[\exposed]]</dfn>
          <td>`false`
          <td>A flag indicating that the {{Gamepad}} object has been exposed to script.
        <tr>
          <td><dfn data-dfn-for="Gamepad">[[\axisMapping]]</dfn>
          <td>An empty [=ordered map=].
          <td>Mapping from unmapped axis index to an index in the {{Gamepad/axes}} array
        <tr>
          <td><dfn data-dfn-for="Gamepad">[[\axisMinimums]]</dfn>
          <td>An empty [=list=].
          <td>A [=list=] containing the minimum logical value for each axis.
        <tr>
          <td><dfn data-dfn-for="Gamepad">[[\axisMaximums]]</dfn>
          <td>An empty [=list=].
          <td>A [=list=] containing the maximum logical value for each axis.
        <tr>
          <td><dfn data-dfn-for="Gamepad">[[\buttonMapping]]</dfn>
          <td>An empty [=ordered map=].
          <td>Mapping from unmapped button index to an index in the {{Gamepad/buttons}} array
        <tr>
          <td><dfn data-dfn-for="Gamepad">[[\buttonMinimums]]</dfn>
          <td>An empty [=list=].
          <td>A [=list=] containing the minimum logical value for each button.
        <tr>
          <td><dfn data-dfn-for="Gamepad">[[\buttonMaximums]]</dfn>
          <td>An empty [=list=].
          <td>A [=list=] containing the maximum logical value for each button.
      </table>
      <dl>
        <dt>
          <dfn>id</dfn> attribute
        </dt>
        <dd>
          An identification string for the gamepad. This string identifies the
          brand or style of connected gamepad device. Typically, this will
          include the USB vendor and a product ID.
        </dd>
        <dt>
          <dfn>index</dfn> attribute
        </dt>
        <dd>
          The index of the gamepad in the {{Navigator}}. When multiple gamepads
          are connected to a <a>user agent</a>, indices MUST be assigned on a
          first-come, first-serve basis, starting at zero. If a gamepad is
          disconnected, previously assigned indices MUST NOT be reassigned to
          gamepads that continue to be connected. However, if a gamepad is
          disconnected, and subsequently the same or a different gamepad is
          then connected, the lowest previously used index MUST be reused.
        </dd>
        <dt>
          <dfn>connected</dfn> attribute
        </dt>
        <dd>
          Indicates whether the physical device represented by this object is
          still connected to the system. When a gamepad becomes unavailable,
          whether by being physically disconnected, powered off or otherwise
          unusable, the `connected` attribute MUST be set to false.
        </dd>
        <dt>
          <dfn>timestamp</dfn> attribute
        </dt>
        <dd>
          Last time the data for this gamepad was updated. Timestamp is a
          monotonically increasing value that allows the author to determine if
          the <a>axes</a> and <a>button</a> data have been updated from the
          hardware. The value must be set to the [=current high resolution time=].
          Since values are monotonically
          increasing they can be compared to determine the ordering of updates,
          as newer values will always be greater than or equal to older values.
          If no data has been received from the hardware, the value of the
          <code>timestamp</code> attribute should be the time relative to
          <code>navigationStart</code> when the <a>Gamepad</a> object was first
          made available to script.
        </dd>
        <dt>
          <dfn>mapping</dfn> attribute
        </dt>
        <dd>
          The mapping in use for this device. If the user agent has knowledge
          of the layout of the device, then it SHOULD indicate that a mapping
          is in use by setting this property to a known mapping name. Currently
          the only known mapping is {{GamepadMappingType["standard"]}}, which
          corresponds to the <a>Standard Gamepad layout</a>. If the user agent
          does not have knowledge of the device layout and is simply providing
          the controls as represented by the driver in use, then it MUST set
          the `mapping` property to the empty string.
        </dd>
        <dt>
          <dfn>axes</dfn> attribute
        </dt>
        <dd>
          Array of values for all axes of the gamepad. All axis values MUST be
          linearly normalized to the range [-1.0 .. 1.0]. If the controller is
          perpendicular to the ground with the directional stick pointing up,
          -1.0 SHOULD correspond to "forward" or "left", and 1.0 SHOULD
          correspond to "backward" or "right". Axes that are drawn from a 2D
          input device SHOULD appear next to each other in the axes array, X
          then Y. It is RECOMMENDED that axes appear in decreasing order of
          importance, such that element 0 and 1 typically represent the X and Y
          axis of a directional stick. The same object MUST be returned until
          the <a>user agent</a> needs to return different values (or values in
          a different order).
        </dd>
        <dt>
          <dfn>buttons</dfn> attribute
        </dt>
        <dd>
          Array of button states for all buttons of the gamepad. It is
          RECOMMENDED that buttons appear in decreasing importance such that
          the primary button, secondary button, tertiary button, and so on
          appear as elements 0, 1, 2, ... in the buttons array. The same object
          MUST be returned until the <a>user agent</a> needs to return
          different values (or values in a different order).
        </dd>
      </dl>
      <h3>Receiving new input values</h3>
      <p>
        When the system receives new input values from a gamepad, run the following steps:
      </p>
      <ol>
        <li>Let |gamepad:Gamepad| be the {{Gamepad}} instance in |navigator:Navigator|.{{Navigator/[[gamepads]]}} representing the gamepad.
        <li>Queue a task (where?) to <a>update gamepad state</a> for |gamepad| with |axisValues| and |buttonValues|.
      </ol>
      <p>
        To <dfn>update gamepad state</dfn> for |gamepad| with an <a>ordered array of logical axis input values</a> |axisValues:sequence&lt;unsigned long&gt;| and an <a>ordered array of logical button input values</a> |buttonValues:sequence&lt;unsigned long&gt;|, run the following steps:
      </p>
      <ol>
        <li>Let |now| be the [=current high resolution time=].
        <li>Set |gamepad|.{{Gamepad/timestamp}} to |now|.
        <li>Run the steps for <a>map and normalize axes</a> with |gamepad|.
        <li>Run the steps for <a>map and normalize buttons</a> with |gamepad|.
        <li>If |navigator|.{{Navigator/[[hasGamepadGesture]]}} is `false` and |gamepad| <a>contains a gamepad user gesture</a>:
          <ol>
            <li>Set |navigator|.{{Navigator/[[hasGamepadGesture]]}} to `true`.
            <li>For each |connectedGamepad:Gamepad| of |navigator|.{{Navigator/[[gamepads]]}}:
              <ol>
                <li>If |connectedGamepad| is not `null`:
                  <ol>
                    <li>Set |connectedGamepad|.{{Gamepad/timestamp}} to |now|.
                    <li>[[=Fire an event=]] named `"gamepadconnected"` at |window:Window| using {{GamepadEvent}} with its {{GamepadEvent/gamepad}} attribute initialized to |connectedGamepad|.
                  </ol>
              </ol>
          </ol>
      </ol>
      <p>
        To <dfn>map and normalize axes</dfn> for a {{Gamepad}} |gamepad:Gamepad|, run the following steps:
      </p>
      <ol>
        <li>Let |axisValues:sequence&lt;unsigned long&gt;| be the gamepad's <a>ordered array of logical axis input values</a>.
        <li>Let |axisCount:long| be the length of |axisValues|.
        <li>Initialize |rawAxisIndex:long| to be 0.
        <li>While |rawAxisIndex| < |axisCount|:
          <ol>
            <li>Let |mappedIndex:long| be the value for key |rawAxisIndex| in |gamepad|.{{[[axisMapping]]}}.
            <li>Let |logicalValue:unsigned long| be the value at index |rawAxisIndex| in |axisValues|.
            <li>Let |logicalMinimum:unsigned long| be the value for key |rawAxisIndex| in |gamepad|.{{Gamepad/[[axisMinimums]]}}.
            <li>Let |logicalMaximum:unsigned long| be the value for key |rawAxisIndex| in |gamepad|.{{Gamepad/[[axisMaximums]]}}.
            <li>Let |normalizedValue:double| be 2 (|logicalValue| − |logicalMinimum|) / (|logicalMaximum| − |logicalMinimum|) − 1.
            <li>Set the value at index |axisIndex| of |gamepad|.{{Gamepad/axes}} to |normalizedValue|.
            <li>Increment |rawAxisIndex|.
          </ol>
      </ol>
      <p>
        To <dfn>map and normalize buttons</dfn> for a {{Gamepad}} |gamepad:Gamepad|, run the following steps:
      </p>
      <ol>
        <li>Let |buttonValues:sequence&lt;unsigned long&gt;| be the gamepad's <a>ordered array of logical button input values</a>.
        <li>Let |buttonCount:long| be the length of |buttonValues|.
        <li>Initialize |rawButtonIndex:long| to be 0.
        <li>While |rawButtonIndex| < |buttonCount|:
          <ol>
            <li>Let |mappedIndex:long| be the value for key |rawButtonIndex| in |gamepad|.{{[[buttonMapping]]}}.
            <li>Let |logicalValue:unsigned long| be the value at index |rawButtonIndex| in |buttonValues|.
            <li>Let |logicalMinimum:unsigned long| be the value for key |rawButtonIndex| in |gamepad|.{{Gamepad/[[buttonMinimums]]}}.
            <li>Let |logicalMaximum:unsigned long| be the value for key |rawButtonIndex| in |gamepad|.{{Gamepad/[[buttonMaximums]]}}.
            <li>Let |normalizedValue:double| be (|logicalValue| − |logicalMinimum|) / (|logicalMaximum| − |logicalMinimum|).
            <li>Let |button:GamepadButton| be the {{GamepadButton}} object at index |mappedIndex| of |gamepad|.{{Gamepad/buttons}}.
            <li>Set |button|.{{GamepadButton/value}} to |normalizedValue|.
            <li>If the button has a digital switch to indicate a pure pressed or released state, set |button|.{{GamepadButton/pressed}} to `true` if the button is pressed or `false` if it is not pressed.
              <p>
                Otherwise, set |button|.{{GamepadButton/pressed}} to `true` if the value is above the <a>button press threshold</a> or `false` if it is not above the threshold.
              </p>
            <li>If the button is capable of detecting touch, set |button|.{{GamepadButton/touched}} to `true` if the button is currently being touched.
              <p>
                Otherwise, set |button|.{{GamepadButton/touched}} to |button|.{{GamepadButton/pressed}}.
              </p>
            <li>Increment |rawButtonIndex|.
          </ol>
      </ol>
      <p>
        The <a>user agent</a> MUST provide methods for retrieving <dfn data-lt="ordered array of axis inputs">ordered arrays of axis inputs</dfn> and <dfn data-lt="ordered array of button inputs">button inputs</dfn> for a gamepad such that there is a unique element in the axis array for each axis input and a unique element in the button array for each button input.
        If the system enumerates axis and button inputs in a consistent order, then the methods SHOULD provide the inputs in that order.
        Otherwise, the methods MAY use any consistent ordering.
      </p>
      <p>
        The <a>user agent</a> MUST provide methods for retrieving <dfn data-lt="ordered array of minimum logical values">ordered arrays of minimum logical values</dfn> and <dfn data-lt="ordered array of maximum logical values">maximum logical values</dfn> for each gamepad input.
        The ordering of these arrays MUST match the ordering of the <a>ordered array of axis inputs</a> and <a>ordered array of button inputs</a>.
      </p>
      <p>
        The <a>user agent</a> MUST provide methods for retrieving <dfn data-lt="ordered array of logical axis input values">ordered arrays of logical axis input values</dfn> and <dfn data-lt="ordered array of logical button input values">button input values</dfn>.
        These arrays MUST contain the most recent values received from the gamepad for each button and axis input.
        The ordering of these arrays MUST match the ordering of the <a>ordered array of axis inputs</a> and <a>ordered array of button inputs</a>.
      </p>
    </section>
    <section data-dfn-for="GamepadButton" data-link-for="GamepadButton">
      <h2>
        <dfn>GamepadButton</dfn> Interface
      </h2>
      <p>
        This interface defines the state of an individual button on a gamepad
        device.
      </p>
      <pre class="idl">
        [Exposed=Window, SecureContext]
        interface GamepadButton {
          readonly attribute boolean pressed;
          readonly attribute boolean touched;
          readonly attribute double value;
        };
      </pre>
      <dl>
        <dt>
          <dfn>pressed</dfn> attribute
        </dt>
        <dd>
          The pressed state of the button. This property MUST be true if the
          button is currently pressed, and false if it is not pressed. For
          buttons which do not have a digital switch to indicate a pure pressed
          or released state, the <a>user agent</a> MUST choose a <dfn>button press threshold</dfn>
          to indicate the button as pressed when its value is above a
          certain amount. If the platform API gives a recommended value, the
          user agent SHOULD use that. In other cases, the user agent SHOULD
          choose some other reasonable value.
        </dd>
        <dt>
          <dfn>touched</dfn> attribute
        </dt>
        <dd>
          The touched state of the button. If the button is capable of
          detecting touch, this property MUST be true if the button is
          currently being touched, and false otherwise. If the button is not
          capable of detecting touch and is capable of reporting an analog
          value, this property MUST be true if the value property is greater
          than 0, and false if the value is 0. If the button is not capable of
          detecting touch and can only report a digital value, this property
          MUST mirror the <a>pressed</a> attribute.
        </dd>
        <dt>
          <dfn>value</dfn> attribute
        </dt>
        <dd>
          For buttons that have an analog sensor, this property MUST represent
          the amount which the button has been pressed. All button values MUST
          be linearly normalized to the range [0.0 .. 1.0]. 0.0 MUST mean fully
          unpressed, and 1.0 MUST mean fully pressed. For buttons without an
          analog sensor, only the values 0.0 and 1.0 for fully unpressed and
          fully pressed respectively, MUST be provided.
        </dd>
      </dl>
    </section>
    <section data-dfn-for="GamepadMappingType">
      <h2>
        <dfn>GamepadMappingType</dfn> enum
      </h2>
      <p>
        This enum defines the set of known mappings for a Gamepad.
      </p>
      <pre class="idl">
        enum GamepadMappingType {
          "",
          "standard",
          "xr-standard",
        };
      </pre>
      <dl>
        <dt>
          <dfn>""</dfn>
        </dt>
        <dd>
          The empty string indicates that no mapping is in use for this
          gamepad.
        </dd>
        <dt>
          <dfn>standard</dfn>
        </dt>
        <dd>
          The Gamepad's controls have been mapped to the <a href=
          "#remapping">Standard Gamepad layout</a>.
        </dd>
        <dt>
          <dfn>xr-standard</dfn>
        </dt>
        <dd data-cite="webxr-gamepads-module">
          The Gamepad's controls have been mapped to the [="xr-standard"
          gamepad mapping=]. This mapping is reserved for use by the
          [[[webxr-gamepads-module-1]]]. Gamepads returned by
          {{Navigator/getGamepads()}} MUST NOT report a {{Gamepad/mapping}} of
          {{GamepadMappingType["xr-standard"]}}.
        </dd>
      </dl>
    </section>
    <section data-dfn-for="Navigator">
      <h2>
        Extensions to the `Navigator` interface
      </h2>
      <pre class="idl">
        [Exposed=Window]
        partial interface Navigator {
          sequence&lt;Gamepad?&gt; getGamepads();
        };
      </pre>
      <p>
        Instances of {{Navigator}} are created with the internal slots described in the following table:
      </p>
      <table class="simple" dfn-for="Navigator">
        <tr>
          <th>Internal slot
          <th>Initial value
          <th>Description (non-normative)
        <tr>
          <td><dfn data-dfn-for="Navigator">[[\hasGamepadGesture]]</dfn>
          <td>`false`
          <td>A flag indicating that a <a>gamepad user gesture</a> has been observed
        <tr>
          <td><dfn data-dfn-for="Navigator">[[\gamepads]]</dfn>
          <td>`[]`
          <td>A `sequence&lt;Gamepad?&gt;` with each {{Gamepad}} present at the index specified by its {{Gamepad/index}} attribute, or `null` for unassigned indices.
      </table>
      <section>
        <h3><dfn>getGamepads()</dfn> method</h3>
        <p class="note">
          The gamepad state returned from {{Navigator/getGamepads()}} does
          not reflect disconnection or connection until after the
          <a>gamepaddisconnected</a> or <a>gamepadconnected</a> events have
          fired.
        </p>
        <p class="note">
          To mitigate fingerprinting, {{Navigator/getGamepads()}} returns an empty list before a <a>gamepad user gesture</a> has been seen. [[FINGERPRINTING-GUIDANCE]]
        </p>
        <aside class="example">
          {{Navigator/getGamepads()}} returns a snapshot of the data for the currently connected and interacted-with gamepads.
          When a gamepad is no longer connected, its index in the array should return `null`.
          If there is one connected gamepad with an index of 1, then the following code snippet describes the expected behavior:
          <pre class="js">
            // gamepads should look like [null, [object Gamepad]]
            var gamepads = navigator.getGamepads();
            // The following statements should all evaluate to true.
            gamepads[0] == null;
            gamepads[1].index == 1;
            gamepads.length == 2;
          </pre>
        </aside>
        <p>
          The {{Navigator/getGamepads()}} method steps are:
        </p>
        <ol>
          <li>If the [=current settings object=]'s [=environment settings object / responsible document=] is not [=allowed to use=] the `"gamepad"` permission, then [=exception/throw=] a {{"SecurityError"}} {{DOMException}} and abort these steps.
          <li>If |navigator:Navigator|.{{Navigator/[[hasGamepadGesture]]}} is `false`, then return an empty list.
          <li>Let |gamepads:sequence&lt;Gamepad?&gt;| be a copy of |navigator|.{{Navigator/[[gamepads]]}}.
          <li>Let |now| be the [=current high resolution time=].
          <li>For each |gamepad:Gamepad| of |gamepads|:
            <ol>
              <li>If |gamepad| is not `null` and |gamepad|.{{Gamepad/[[exposed]]}} is `false`:
                <ol>
                  <li>Set |gamepad|.{{Gamepad/[[exposed]]}} to `true`.
                  <li>Set |gamepad|.{{Gamepad/timestamp}} to |now|.
                </ol>
            </ol>
          <li>Return |gamepads|.
        </ol>
        <p>
          A |gamepad:Gamepad| <dfn data-lt="gamepad user gesture">contains a gamepad user gesture</dfn> if the current input state indicates that the user is currently interacting with the gamepad.
          The <a>user agent</a> MUST provide a method to check if the input state contains a gamepad user gesture.
          For buttons that support a neutral default value and have reported a {{GamepadButton/pressed}} value of `false` at least once, a {{GamepadButton/pressed}} value of `true` SHOULD be considered interaction.
          If a button does not support a neutral default value (for example, a toggle switch), then a {{GamepadButton/pressed}} value of `true` SHOULD NOT be considered interaction.
          If a button has never reported a {{GamepadButton/pressed}} value of `false` then it SHOULD NOT be considered interaction.
          Axis movements SHOULD be considered interaction if the axis supports a neutral default value, the current displacement from neutral is greater than a threshold chosen by the <a>user agent</a>, and the axis has reported a value below the threshold at least once.
          If an axis does not support a neutral default value (for example, an axis for a joystick that does not self-center), or an axis has never reported a value below the axis gesture threshold, then the axis SHOULD NOT be considered when checking for interaction.
          The axis gesture threshold SHOULD be large enough that random jitter is not considered interaction.
      </section>
    </section>
    <section data-dfn-for="GamepadEvent">
      <h2>
        <dfn>GamepadEvent</dfn> Interface
      </h2>
      <pre class="idl" data-cite="DOM">
        [Exposed=Window, SecureContext]

        interface GamepadEvent: Event {
          constructor(DOMString type, GamepadEventInit eventInitDict);
          [SameObject] readonly attribute Gamepad gamepad;
        };
      </pre>
      <dl>
        <dt>
          <dfn>gamepad</dfn>
        </dt>
        <dd>
          The single gamepad attribute provides access to the associated
          gamepad data for this event.
        </dd>
      </dl>
      <section>
        <h3>
          <dfn>GamepadEventInit</dfn> dictionary
        </h3>
        <pre class="idl" data-cite="DOM">
        dictionary GamepadEventInit : EventInit {
          required Gamepad gamepad;
        };
      </pre>
        <dl data-dfn-for="GamepadEventInit">
          <dt>
            <dfn>gamepad</dfn> member
          </dt>
          <dd>
            The gamepad associated with this event.
          </dd>
        </dl>
      </section>
    </section>
    <section>
      <h2>
        <dfn data-lt="Standard Gamepad layout">Remapping</dfn>
      </h2>
      <p>
        Each device manufacturer creates many different products and each has
        unique styles and layouts of buttons and axes. It is intended that the
        <a>user agent</a> support as many of these as possible.
      </p>
      <p>
        Additionally there are <em>de facto</em> standard layouts that have
        been made popular by game consoles. When the <a>user agent</a>
        recognizes the attached device, it is RECOMMENDED that it be remapped
        to a canonical ordering when possible. Devices that are not recognized
        should still be exposed in their raw form.
      </p>
      <p data-link-for="Gamepad">
        There is currently one canonical device, the "Standard Gamepad". The
        standard gamepad has 4 axes, and up to 17 buttons. When remapping, the
        indices in <a>axes</a>[] and <a>buttons</a>[] should correspond as
        closely as possible to the physical locations in the diagram below.
        Additionally, the <a>mapping</a> property of the Gamepad SHOULD be set
        to the string {{GamepadMappingType["standard"]}}.
      </p>
      <p>
        The "Standard Gamepad" physical button locations are layed out in a
        left cluster of four buttons, a right cluster of four buttons, a center
        cluster of three buttons, and a pair of front facing buttons on the
        left and right side of the gamepad. The four axes of the "Standard
        Gamepad" are associated with a pair of analog sticks, one on the left
        and one on the right. The following table describes the buttons/axes
        and their physical locations.
      </p>
      <p>
        An axis input <dfn>represents a Standard Gamepad axis</dfn> if it reports the input value for a joystick axis, the joystick is located in approximately the same location as the corresponding Standard Gamepad joystick, and the orientation of the axis (up-down or left-right) matches the orientation of the Standard Gamepad axis.
        If there are multiple axes that represent the same Standard Gamepad axis, then the <a>user agent</a> SHOULD select one to be the Standard Gamepad axis and assign a different index to the other axis.
      </p>
      <p>
        A button input <dfn>represents a Standard Gamepad button</dfn> if it reports the input value for a button or trigger, and the button or trigger is located in approximately the same location as the corresponding Standard Gamepad input.
      </p>
      <p>
        If an axis or button input represents a Standard Gamepad axis or button, then its <dfn>canonical index</dfn> is the index of the corresponding Standard Gamepad axis or button.
      </p>
      <table class="tg">
        <thead>
          <tr>
            <th>
              Button/Axis
            </th>
            <th>
              Location
            </th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              buttons[0]
            </td>
            <td>
              Bottom button in right cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[1]
            </td>
            <td>
              Right button in right cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[2]
            </td>
            <td>
              Left button in right cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[3]
            </td>
            <td>
              Top button in right cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[4]
            </td>
            <td>
              Top left front button
            </td>
          </tr>
          <tr>
            <td>
              buttons[5]
            </td>
            <td>
              Top right front button
            </td>
          </tr>
          <tr>
            <td>
              buttons[6]
            </td>
            <td>
              Bottom left front button
            </td>
          </tr>
          <tr>
            <td>
              buttons[7]
            </td>
            <td>
              Bottom right front button
            </td>
          </tr>
          <tr>
            <td>
              buttons[8]
            </td>
            <td>
              Left button in center cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[9]
            </td>
            <td>
              Right button in center cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[10]
            </td>
            <td>
              Left stick pressed button
            </td>
          </tr>
          <tr>
            <td>
              buttons[11]
            </td>
            <td>
              Right stick pressed button
            </td>
          </tr>
          <tr>
            <td>
              buttons[12]
            </td>
            <td>
              Top button in left cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[13]
            </td>
            <td>
              Bottom button in left cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[14]
            </td>
            <td>
              Left button in left cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[15]
            </td>
            <td>
              Right button in left cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[16]
            </td>
            <td>
              Center button in center cluster
            </td>
          </tr>
          <tr>
            <td>
              axes[0]
            </td>
            <td>
              Horizontal axis for left stick (negative left/positive right)
            </td>
          </tr>
          <tr>
            <td>
              axes[1]
            </td>
            <td>
              Vertical axis for left stick (negative up/positive down)
            </td>
          </tr>
          <tr>
            <td>
              axes[2]
            </td>
            <td>
              Horizontal axis for right stick (negative left/positive right)
            </td>
          </tr>
          <tr>
            <td>
              axes[3]
            </td>
            <td>
              Vertical axis for right stick (negative up/positive down)
            </td>
          </tr>
        </tbody>
      </table>
      <figure>
        <img src="standard_gamepad.svg" alt="">
        <figcaption>
          Visual representation of a standard gamepad layout.
        </figcaption>
      </figure>
    </section>
    <section class="informative">
      <h2>
        Usage Examples
      </h2>
      <p>
        The example below demonstrates typical access to gamepads. Note the
        relationship with the
        {{AnimationFrameProvider/requestAnimationFrame()}} method.
      </p>
      <pre class="example js">
        function runAnimation() {
            window.requestAnimationFrame(runAnimation);
            for (const pad of navigator.getGamepads()) {
              // todo; simple demo of displaying pad.axes and pad.buttons
              console.log(pad);
            }
        }

        window.requestAnimationFrame(runAnimation);
      </pre>
      <div class="practice">
        <span id="practice-timing" class="practicelab">Coordination with
        <code>requestAnimationFrame()</code></span>
        <p class="practicedesc">
          Interactive applications will typically be using the
          {{AnimationFrameProvider/requestAnimationFrame()}} method to drive
          animation, and will want coordinate animation with user gamepad
          input. As such, the gamepad data should be polled as closely as
          possible to immediately before the animation callbacks are executed,
          and with frequency matching that of the animation. That is, if the
          animation callbacks are running at 60Hz, the gamepad inputs should
          also be sampled at that rate.
        </p>
      </div>
    </section>
    <section>
      <h3 id="event-gamepadconnected">
        The <dfn class="event">gamepadconnected</dfn> event
      </h3>
      <p>
        When a gamepad becomes available on the system, run the following steps:
      </p>
      <ol>
        <li>If the [=current settings object=]'s [=environment settings object / responsible document=] is not [=allowed to use=] the `"gamepad"` permission, then abort these steps.
        <li>Let |now| be the [=current high resolution time=].
        <li>Let |gamepadIndex:long| be the result of <a>selecting an unused gamepad index</a>.
        <li>Let |gamepad:Gamepad| be a {{Gamepad}}.
        <li>Set |gamepad|.{{Gamepad/id}} to an identification string for the gamepad.
        <li>Set |gamepad|.{{Gamepad/index}} to |gamepadIndex|.
        <li>Set |gamepad|.{{Gamepad/connected}} to `true`.
        <li>Set |gamepad|.{{Gamepad/timestamp}} to |now|.
        <li>Set |gamepad|.{{Gamepad/mapping}} to the result of <a>selecting a mapping</a>.
        <li>Set |gamepad|.{{Gamepad/axes}} to the result of <a>initializing axes</a>.
        <li>Set |gamepad|.{{Gamepad/buttons}} to the result of <a>initializing buttons</a>.
        <li>If |navigator|.{{Navigator/[[hasGamepadGesture]]}} is `true`:
          <ol>
            <li>Set |gamepad|.{{Gamepad/[[exposed]]}} to `true`.
            <li>Let |window:Window| be ...?
            <li>[[=Fire an event=]] named `"gamepadconnected"` at |window:Window| using {{GamepadEvent}} with its {{GamepadEvent/gamepad}} attribute initialized to |gamepad|.
          </ol>
        <li>Set the value at index |gamepadIndex:long| in |navigator:Navigator|.{{Navigator/[[gamepads]]}} to |gamepad|.
      </ol>
      <p>
        To <dfn data-lt="selecting an unused gamepad index">select an unused gamepad index</dfn>, run the following steps:
      </p>
      <ol>
        <li>Let |gamepadsLength:long| be the length of |navigator|.{{Navigator/[[gamepads]]}}.
        <li>Initialize |gamepadIndex:long| to be 0.
        <li>While |gamepadIndex| < |gamepadsLength|:
          <ol>
            <li>Let |gamepad:Gamepad?| be the value at index |gamepadIndex| in |navigator|.{{Navigator/[[gamepads]]}}.
            <li>If |gamepad| is `null`, then return |gamepadIndex|.
            <li>Increment |gamepadIndex|.
          </ol>
        <li>Append `null` to |navigator|.{{Navigator/[[gamepads]]}}.
        <li>Return |gamepadIndex|.
      </ol>
      <p>
        To <dfn data-lt="selecting a mapping">select a mapping</dfn> for a gamepad device, run the following steps:
      </p>
      <ol>
        <li>If the button and axis layout of the gamepad device corresponds with the <a>Standard Gamepad layout</a>, then return `"standard"`.
        <li>Return `""`.
      </ol>
      <p>
        To <dfn data-lt="initializing axes">initialize axes</dfn> for |gamepad:Gamepad|, run the following steps:
      </p>
      <ol>
        <li>Let |inputs| be the gamepad's <a>ordered array of axis inputs</a>.
        <li>Let |inputMinimums:sequence&lt;unsigned long&gt;| be an <a>ordered array of minimum logical values</a> for the axes in |inputs|.
        <li>Let |inputMaximums:sequence&lt;unsigned long&gt;| be an <a>ordered array of maximum logical values</a> for the axes in |inputs|.
        <li>Let |inputCount:long| be the length of |inputs|.
        <li>Set |gamepad|.{{Gamepad/[[axisMinimums]]}} to |inputMinimums|.
        <li>Set |gamepad|.{{Gamepad/[[axisMaximums]]}} to |inputMaximums|.
        <li>Initialize |unmappedInputList:sequence&lt;long&gt;| to be an empty list.
        <li>Initialize |mappedIndexList:sequence&lt;long&gt;| to be an empty list.
        <li>Initialize |axesLength:long| to be 0.
        <li>Initialize |rawInputIndex:long| to be 0.
        <li>While |rawInputIndex| < |inputCount|:
          <ol>
            <li>If the the gamepad axis at index |rawInputIndex| <a>represents a Standard Gamepad axis</a>:
              <ol>
                <li>Let |canonicalIndex:long| be the <a>canonical index</a> for the axis.
                <li>If |mappedIndexList| contains |canonicalIndex|, then append |rawInputIndex| to |unmappedInputList|.
                  <p>
                    Otherwise:
                  </p>
                  <ol>
                    <li>Set the value for key |rawInputIndex| in |gamepad|.{{Gamepad/[[axisMapping]]}} to |canonicalIndex|.
                    <li>Append |canonicalIndex| to |mappedIndexList|.
                    <li>If |canonicalIndex| + 1 > |axesLength|, then set |axesLength| to |canonicalIndex| + 1.
                  </ol>
              </ol>
              <p>
                Otherwise, append |rawInputIndex| to |unmappedInputList|.
              </p>
            <li>Increment |rawInputIndex|.
          </ol>
        <li>Initialize |axes:sequence&lt;long&gt;| to be an empty list.
        <li>Initialize |axisIndex:long| to be 0.
        <li>For each input index |rawInputIndex:long| of |unmappedInputList|:
          <ol>
            <li>While |mappedIndexList| contains |axisIndex|:
              <ol>
                <li>Increment |axisIndex|.
              </ol>
            <li>Set the value for key |rawInputIndex| in |gamepad|.{{Gamepad/[[axisMapping]]}} to |axisIndex|.
            <li>Append |axisIndex| to |mappedIndexList|.
            <li>If |axisIndex| + 1 > |axesLength|, then set |axesLength| to |axisIndex| + 1.
          </ol>
        <li>Set |axisIndex| to 0.
        <li>While |axisIndex| < |axesLength|:
          <ol>
            <li>Append 0 to |axes|.
            <li>Increment |axisIndex|.
          </ol>
        <li>Return |axes|.
      </ol>
      <p>
        To <dfn data-lt="initializing buttons">initialize buttons</dfn> for a gamepad, run the following steps:
      </p>
      <ol>
        <li>Let |inputs| be the gamepad's <a>ordered array of button inputs</a>.
        <li>Let |inputMinimums:sequence&lt;unsigned long&gt;| be an <a>ordered array of minimum logical values</a> for the buttons in |inputs|.
        <li>Let |inputMaximums:sequence&lt;unsigned long&gt;| be an <a>ordered array of maximum logical values</a> for the buttons in |inputs|.
        <li>Let |inputCount:long| be the length of |inputs|.
        <li>Set |gamepad|.{{Gamepad/[[buttonMinimums]]}} to |inputMinimums|.
        <li>Set |gamepad|.{{Gamepad/[[buttonMaximums]]}} to |inputMaximums|.
        <li>Initialize |unmappedInputList:sequence&lt;long&gt;| to be an empty list.
        <li>Initialize |mappedIndexList:sequence&lt;long&gt;| to be an empty list.
        <li>Initialize |buttonsLength:long| to be 0.
        <li>Initialize |rawInputIndex:long| to be 0.
        <li>While |rawInputIndex| < |inputCount|:
          <ol>
            <li>If the the gamepad button at index |rawInputIndex| <a>represents a Standard Gamepad button</a>:
              <ol>
                <li>Let |canonicalIndex:long| be the <a>canonical index</a> for the button.
                <li>If |mappedIndexList| contains |canonicalIndex|, then append |rawInputIndex| to |unmappedInputList|.
                  <p>
                    Otherwise:
                  </p>
                  <ol>
                    <li>Set the value for key |rawInputIndex| in |gamepad|.{{Gamepad/[[buttonMapping]]}} to |canonicalIndex|.
                    <li>Append |canonicalIndex| to |mappedIndexList|.
                    <li>If |canonicalIndex| + 1 > |buttonsLength|, then set |buttonsLength| to |canonicalIndex| + 1.
                  </ol>
              </ol>
              <p>
                Otherwise, append |rawInputIndex| to |unmappedInputList|.
              </p>
            <li>Increment |rawInputIndex|.
          </ol>
        <li>Initialize |buttons:sequence&lt;GamepadButton&gt;| to be an empty list.
        <li>Initialize |buttonIndex:long| to be 0.
        <li>For each input index |rawInputIndex:long| of |unmappedInputList|:
          <ol>
            <li>While |mappedIndexList| contains |buttonIndex|:
              <ol>
                <li>Increment |buttonIndex|.
              </ol>
            <li>Set the value for key |rawInputIndex| in |gamepad|.{{Gamepad/[[buttonMapping]]}} to |buttonIndex|.
            <li>Append |buttonIndex| to |mappedIndexList|.
            <li>If |buttonIndex| + 1 > |buttonsLength|, then set |buttonsLength| to |buttonIndex| + 1.
          </ol>
        <li>Set |buttonIndex| to 0.
        <li>While |buttonIndex| < |buttonsLength|:
          <ol>
            <li>Let |button:GamepadButton| be a {{GamepadButton}}.
            <li>Set |button|.{{GamepadButton/pressed}} to `false`.
            <li>Set |button|.{{GamepadButton/touched}} to `false`.
            <li>Set |button|.{{GamepadButton/value}} to 0.
            <li>Append |button| to |buttons|.
            <li>Increment |buttonIndex|.
          </ol>
        <li>Return |buttons|.
      </ol>
      <p>
        User agents implementing this specification must provide a new DOM
        event, named <code>gamepadconnected</code>. The corresponding event
        MUST be of type {{GamepadEvent}} and, if <a>allowed to use</a> the
        "`gamepad`" permission, MUST fire on the <code>window</code> object.
        Registration for and firing of the <code>gamepadconnected</code> event
        MUST follow the usual behavior of DOM Events. [[DOM]]
      </p>
      <p>
        A <a>user agent</a> MUST dispatch this event type to indicate the user
        has connected a gamepad. If a gamepad was already connected when the
        page was loaded, the <a>gamepadconnected</a> event SHOULD be dispatched
        when the user presses a button or moves an axis.
      </p>
      <p>
        A <a>user agent</a> MUST NOT dispatch this event type if the
        <a>environment settings object</a> is a <a>non-secure context</a>.
      </p>
    </section>
    <section>
      <h3 id="event-gamepaddisconnected">
        The <dfn class="event">gamepaddisconnected</dfn> event
      </h3>
      <p>
        When a gamepad becomes unavailable on the system, run the following steps:
      </p>
      <ol>
        <li>If the [=current settings object=]'s [=environment settings object / responsible document=] is not [=allowed to use=] the `"gamepad"` permission, then abort these steps.
        <li>Let |gamepad:Gamepad| be the {{Gamepad}} instance in |navigator:Navigator|.{{Navigator/[[gamepads]]}} representing the gamepad.
        <li>Set |gamepad|.{{Gamepad/connected}} to `false`.
        <li>If |gamepad|.{{Gamepad/[[exposed]]}} is `false`, then abort these steps.
        <li>If |navigator|.{{Navigator/[[hasGamepadGesture]]}} is `false`, then abort these steps.
        <li>Let |window:Window| be ...?
        <li>[[=Fire an event=]] named `"gamepaddisconnected"` at |window| using {{GamepadEvent}} with its {{GamepadEvent/gamepad}} attribute initialized to |gamepad|.
        <li>Set the value at index |gamepad|.{{Gamepad/index}} of |navigator|.{{Navigator/[[gamepads]]}} to `null`.
        <li>Repeat while |navigator|.{{Navigator/[[gamepads]]}} is not empty:
          <ol>
            <li>Let |gamepadsLength:long| be the length of |navigator|.{{Navigator/[[gamepads]]}}.
            <li>Let |lastGamepad:Gamepad| be the value at index |gamepadsLength| − 1 of |navigator|.{{Navigator/[[gamepads]]}}.
            <li>If |lastGamepad| is `null`, then remove the last element |navigator|.{{Navigator/[[gamepads]]}}.
          </ol>
      </ol>
      <p>
        User agents implementing this specification must provide a new DOM
        event, named <code>gamepaddisconnected</code>. The corresponding event
        MUST be of type <code>GamepadEvent</code> and, if <a>allowed to use</a>
        the "`gamepad`" permission, MUST fire on the <code>window</code>
        object. Registration for and firing of the
        <code>gamepaddisconnected</code> event MUST follow the usual behavior
        of DOM Events. [[DOM]]
      </p>
      <p>
        When a gamepad is disconnected from the <a>user agent</a>, if the
        <a>user agent</a> has previously dispatched a <a>gamepadconnected</a>
        event for that gamepad to a window, a <a>gamepaddisconnected</a> event
        MUST be dispatched to that same window.
      </p>
      <p>
        A <a>user agent</a> MUST NOT dispatch this event type if the
        <a>environment settings object</a> is a <a>non-secure context</a>.
      </p>
    </section>
    <section>
      <h3>
        Other events
      </h3>
      <p>
        <i>More discussion needed, on whether to include or exclude axis and
        button changed events, and whether to roll them more together
        (<code>gamepadchanged</code>?), separate somewhat
        (<code>gamepadaxischanged</code>?), or separate by individual axis and
        button.</i>
      </p>
    </section>
    <section>
      <h2>
        Extensions to the `WindowEventHandlers` Interface Mixin
      </h2>
      <p>
        This specification extends the {{WindowEventHandlers}} interface mixin
        from HTML to add [=event handler IDL attributes=] to facilitate the
        event handler registration.
      </p>
      <pre class="idl">
        partial interface mixin WindowEventHandlers {
          attribute EventHandler ongamepadconnected;
          attribute EventHandler ongamepaddisconnected;
        };
      </pre>
    </section>
    <section id="permission-policy" data-cite="permissions-policy">
      <h2>
        Integration with Permissions Policy
      </h2>
      <p>
        This specification defines a policy-controlled feature identified by
        the string "`gamepad`". Its [=default allowlist=] is '`self`'.
      </p>
      <div class="note">
        <p>
          A <a>document</a>’s [=Document/permissions policy=] determines
          whether any content in that document is allowed to access
          {{Navigator/getGamepads()}}. If disabled in any document, no content
          in the document will be <a>allowed to use</a>
          {{Navigator/getGamepads()}}, nor will the "gamepadconnected" and
          "gamepaddisconnected" events fire.
        </p>
      </div>
    </section>
    <section id='conformance'>
      <p>
        This specification defines conformance criteria that apply to a single
        product: the <dfn id="dfn-user-agent">user agent</dfn> that implements
        the interfaces that it contains.
      </p>
    </section>
    <section class='appendix informative'>
      <h2>
        Acknowledgements
      </h2>
      <p>
        Many have made contributions in code, comments, or documentation:
      </p>
      <ul>
        <li>David Humphrey
        </li>
        <li>Gregg Tavares
        </li>
        <li>Marcin Wichary
        </li>
        <li>Jason Orendorff
        </li>
        <li>Olli Pettay
        </li>
        <li>Rick Waldron
        </li>
      </ul>
      <p>
        Please let me know if I have inadvertently omitted your name.
      </p>
    </section>
  </body>
</html>
